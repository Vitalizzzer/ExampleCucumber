"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="../types/intrinsicElements.d.ts" />
/// <reference path="../types/unistTestLine.d.ts" />
var unist_builder_1 = __importDefault(require("unist-builder"));
var plainTypes = ['text', 'code', 'bold', 'emphasis'];
var isTextNode = function (input) { return plainTypes.includes(input.type); };
exports.flatten = function (input) {
    if (Array.isArray(input)) {
        return input.reduce(function (acc, item) { return acc.concat(exports.flatten(item)); }, []);
    }
    return [input];
};
/**
 * Normalize textual children - make them flat and merge sequential text items of same type
 */
var normalizePlainChildren = function (children, parentType) {
    return children.reduce(function (output, child) {
        var _a;
        if (typeof child === 'string') {
            // Wrap plain strings into text nodes
            child = unist_builder_1.default(plainTypes.includes(parentType) ? parentType : 'text', child);
        }
        // Nested child is a textual node
        var lastChild = output[output.length - 1];
        if (isTextNode(child) && ((_a = lastChild) === null || _a === void 0 ? void 0 : _a.type) === child.type) {
            // Textual node with same time as the previous one - merge them
            lastChild.value += child.value;
        }
        else {
            output.push(child);
        }
        return output;
    }, []);
};
var processLabel = function (label) {
    if (typeof label !== 'undefined') {
        return normalizePlainChildren(exports.flatten([label]), 'text');
    }
    return undefined;
};
var isCellChildren = function (children) {
    return children.every(function (child) { return child.type === 'cell'; });
};
var isRowChildren = function (children) {
    return children.every(function (child) { return child.type === 'row'; });
};
var isDictionaryRowChildren = function (children) {
    return children.every(function (child) { return child.type === 'row' && child.children.length === 2; });
};
var isTextChildren = function (children) {
    return children.every(isTextNode);
};
var isSinglePlainTextChildren = function (children) {
    return children.length === 1 && children[0].type === 'text';
};
var assertUnknownIntrinsicElementType = function (type) {
    throw new Error("Unknown intrinsic element type " + type);
};
exports.assertUnknownSectionNode = function (node) {
    throw new Error('Unknown node type: ' + JSON.stringify(node));
};
exports.assertUnknownTextNode = function (node) {
    throw new Error('Unknown plain text node: ' + JSON.stringify(node));
};
/**
 * A factory for JSX elements. Maps React-style JSX to unist-style nodes.
 * "any" is used for children and props because TypeScript can't infer JSX element types
 * anyway and always returns whatever is provided in JSX.Element type/interface.
 * Some validation is added to ensure correct data at least runtime.
 */
exports.jsx = function (type, props) {
    var children = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        children[_i - 2] = arguments[_i];
    }
    var _a, _b, _c, _d;
    // Do not include empty children, to allow for ternary operations in JSX
    // Flatten the children - to support nested arrays in JSX and manage fragments
    var processedChildren = normalizePlainChildren(exports.flatten(children.filter(Boolean)), type);
    switch (type) {
        case 'text':
        case 'bold':
        case 'emphasis':
        case 'code':
            return processedChildren[0];
        case 'fragment':
            return processedChildren;
        case 'cell':
            if (isTextChildren(processedChildren)) {
                return unist_builder_1.default('cell', processedChildren);
            }
            throw new TypeError('Cell can only accept section or textual nodes');
        case 'row':
            if (isCellChildren(processedChildren)) {
                return unist_builder_1.default('row', processedChildren);
            }
            throw new TypeError('Row can only accept Cell as its child');
        case 'table':
            if (isRowChildren(processedChildren)) {
                return unist_builder_1.default('table', { label: processLabel((_a = props) === null || _a === void 0 ? void 0 : _a.label) }, processedChildren);
            }
            throw new TypeError('Table can only accept Row as its child');
        case 'dictionary':
            if (isDictionaryRowChildren(processedChildren)) {
                return unist_builder_1.default('dictionary', { label: processLabel((_b = props) === null || _b === void 0 ? void 0 : _b.label) }, processedChildren);
            }
            throw new TypeError('Dictionary can only accept Row with 2 Cells as its child');
        case 'paragraph':
        case 'condition':
        case 'test-line':
            return unist_builder_1.default(type, { title: processLabel((_c = props) === null || _c === void 0 ? void 0 : _c.title) }, processedChildren);
        case 'code-block':
            if (isSinglePlainTextChildren(processedChildren)) {
                return unist_builder_1.default('code-block', { label: processLabel((_d = props) === null || _d === void 0 ? void 0 : _d.label) }, processedChildren[0].value);
            }
            throw new Error('Code block can only accept plain text children');
        default:
            return assertUnknownIntrinsicElementType(type);
    }
};
//# sourceMappingURL=jsxFactory.js.map