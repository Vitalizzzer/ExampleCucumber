"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="../types/intrinsicElements.d.ts" />
/// <reference path="../types/unistTestLine.d.ts" />
var jsxFactory_1 = require("./jsxFactory");
var conditions_1 = require("./conditions");
var utils_1 = require("./utils");
var renderConditionCountDelay = function (count, delay, vars) { return jsxFactory_1.jsx("dictionary", { label: "Condition settings" },
    jsxFactory_1.jsx("row", null,
        jsxFactory_1.jsx("cell", null, "Repeat"),
        jsxFactory_1.jsx("cell", null, utils_1.formatCount(count, vars))),
    jsxFactory_1.jsx("row", null,
        jsxFactory_1.jsx("cell", null, "Every"),
        jsxFactory_1.jsx("cell", null, utils_1.formatTimeout(delay, vars)))); };
var getConditionInfo = function (testLine, appConfig, elements) {
    // Deconstruct with type casting to PressButtonTestLine, as it's the most complete line type
    // and has all types of conditions and loops
    var _a = testLine, condition = _a.condition, count = _a.count, negateCondition = _a.negateCondition, delay = _a.delay;
    // Do something ... exactly ... every ...
    if (!condition && count && (typeof count === 'string' || count > 1)) {
        return [
            jsxFactory_1.jsx("fragment", null,
                " exactly ",
                utils_1.formatCount((count !== null && count !== void 0 ? count : 1), appConfig.configVariables)),
            renderConditionCountDelay((count !== null && count !== void 0 ? count : 1), (delay !== null && delay !== void 0 ? delay : 0), appConfig.configVariables),
        ];
    }
    // Do something ... only if ...
    if (condition && negateCondition) {
        return [
            jsxFactory_1.jsx("text", null, " only if condition is met"),
            conditions_1.translateCondition(condition, appConfig, elements),
        ];
    }
    // Do something ... until ...
    if (condition && !negateCondition) {
        return [
            jsxFactory_1.jsx("text", null, " until condition is met"),
            jsxFactory_1.jsx("fragment", null,
                renderConditionCountDelay((count !== null && count !== void 0 ? count : 1), (delay !== null && delay !== void 0 ? delay : 0), appConfig.configVariables),
                conditions_1.translateCondition(condition, appConfig, elements)),
        ];
    }
    // Do something ...
    return [undefined, undefined];
};
var assertAssertThen = function (then) {
    throw new Error("Unknown \"then\" in assert: " + then);
};
var translateAssertThen = function (then) {
    switch (then) {
        case 'success': return 'continue';
        case 'exit': return 'stop test';
        case 'fail': return 'fail';
        case 'warning': return 'warn';
        default:
            return assertAssertThen(then);
    }
};
var translateAssertTestLine = function (testLine, appConfig, elements) {
    var condition = conditions_1.translateCondition(testLine.condition, appConfig, elements);
    return jsxFactory_1.jsx("test-line", { title: jsxFactory_1.jsx("fragment", null,
            "Assert: ",
            condition.title) },
        testLine.then !== 'success' || testLine.timeout
            ? jsxFactory_1.jsx("dictionary", null,
                testLine.then === 'success'
                    ? undefined
                    : jsxFactory_1.jsx("row", null,
                        jsxFactory_1.jsx("cell", null, "When passed"),
                        jsxFactory_1.jsx("cell", null, translateAssertThen(testLine.then))),
                testLine.timeout
                    ? jsxFactory_1.jsx("row", null,
                        jsxFactory_1.jsx("cell", null, "Timeout"),
                        jsxFactory_1.jsx("cell", null, utils_1.formatTimeout(testLine.timeout, appConfig.configVariables)))
                    : undefined)
            : undefined,
        condition.children);
};
var translateClearAppDataTestLine = function () {
    return jsxFactory_1.jsx("test-line", { title: "Clear application data" });
};
var translateExecuteCommandTestLine = function (testLine, appConfig) {
    var code = utils_1.replaceVariables(testLine.val, appConfig.configVariables);
    return jsxFactory_1.jsx("test-line", { title: "Execute JavaScript expression" },
        jsxFactory_1.jsx("code-block", { label: "JavaScript expression" }, code),
        code !== testLine.val
            ? jsxFactory_1.jsx("code-block", { label: "With variables" }, testLine.val)
            : undefined);
};
var translateOpenApp = function (testLine, appConfig) {
    if (!testLine.relativeUrl) {
        // Open app with default path
        return jsxFactory_1.jsx("test-line", { title: "Open application" });
    }
    var relativeUrl = utils_1.formatVariables(testLine.relativeUrl, appConfig.configVariables);
    return jsxFactory_1.jsx("test-line", { title: "Open application at relative URL" },
        jsxFactory_1.jsx("dictionary", null,
            jsxFactory_1.jsx("row", null,
                jsxFactory_1.jsx("cell", null, "Relative path"),
                jsxFactory_1.jsx("cell", null, relativeUrl))));
};
var translateOpenUrl = function (testLine, appConfig) {
    var url = utils_1.formatVariables(testLine.url, appConfig.configVariables);
    return jsxFactory_1.jsx("test-line", { title: "Open URL" },
        jsxFactory_1.jsx("dictionary", null,
            jsxFactory_1.jsx("row", null,
                jsxFactory_1.jsx("cell", null, "Exact URL"),
                jsxFactory_1.jsx("cell", null, url))));
};
var translateSleepTestLine = function (testLine, appConfig) {
    var title = jsxFactory_1.jsx("fragment", null,
        "Sleep ",
        utils_1.formatTimeout(testLine.timeout, appConfig.configVariables));
    return jsxFactory_1.jsx("test-line", { title: title });
};
var translatePollUrlTestLine = function (testLine, appConfig) {
    var response = utils_1.formatVariables(testLine.response, appConfig.configVariables);
    var url = utils_1.formatVariables(testLine.url, appConfig.configVariables);
    return jsxFactory_1.jsx("test-line", { title: "Poll URL every 0.5s" },
        jsxFactory_1.jsx("dictionary", null,
            jsxFactory_1.jsx("row", null,
                jsxFactory_1.jsx("cell", null, "Poll URL"),
                jsxFactory_1.jsx("cell", null, url)),
            jsxFactory_1.jsx("row", null,
                jsxFactory_1.jsx("cell", null, "Until receive"),
                jsxFactory_1.jsx("cell", null, response))));
};
var translatePressButtonTestLine = function (testLine, appConfig, elements) {
    var ids = testLine.ids
        .map(function (id, i) { return jsxFactory_1.jsx("fragment", null,
        jsxFactory_1.jsx("bold", null, id),
        i !== testLine.ids.length - 1 ? ', ' : ''); });
    var _a = __read(getConditionInfo(testLine, appConfig, elements), 2), titleFragment = _a[0], condition = _a[1];
    return jsxFactory_1.jsx("test-line", { title: jsxFactory_1.jsx("fragment", null,
            "Press button ",
            ids,
            titleFragment) }, condition);
};
var translateTestName = function (testId, snippets) {
    if (snippets && snippets[testId]) {
        return jsxFactory_1.jsx("bold", null, snippets[testId].name);
    }
    return jsxFactory_1.jsx("fragment", null,
        "(",
        jsxFactory_1.jsx("code", null, testId.slice(0, 4) + '...' + testId.slice(-4)),
        ")");
};
// TODO BE will add snippets to the feed, otherwise we have to do extra requests to get snippet names
var translateRunTestTestLine = function (testLine, appConfig, elements, snippets) {
    var testName = translateTestName(testLine.val, snippets);
    var _a = __read(getConditionInfo(testLine, appConfig, elements), 2), titleFragment = _a[0], condition = _a[1];
    return jsxFactory_1.jsx("test-line", { title: jsxFactory_1.jsx("fragment", null,
            "Run test ",
            testName,
            titleFragment) }, condition);
};
var assertUnknownTarget = function (target) {
    throw new Error('Unknown target: ' + JSON.stringify(target));
};
var translateTarget = function (target) {
    switch (target.type) {
        case 'element':
            return jsxFactory_1.jsx("bold", null, "element");
        case 'window':
            return jsxFactory_1.jsx("bold", null, 'coordinates' in target ? 'position' : 'window');
        default:
            return assertUnknownTarget(target);
    }
};
// TODO what if text is too long?
var translateSendTextTestLine = function (testLine, appConfig, elements) {
    var text = utils_1.formatVariables(testLine.val, appConfig.configVariables);
    var _a = __read(getConditionInfo(testLine, appConfig, elements), 2), titleFragment = _a[0], condition = _a[1];
    var title = jsxFactory_1.jsx("fragment", null,
        "Send text ",
        text,
        " to ",
        translateTarget(testLine.target),
        titleFragment);
    return jsxFactory_1.jsx("test-line", { title: title }, condition);
};
var translateSetTextTestLine = function (testLine, appConfig, elements) {
    var text = utils_1.formatVariables(testLine.val, appConfig.configVariables);
    var _a = __read(getConditionInfo(testLine, appConfig, elements), 2), titleFragment = _a[0], condition = _a[1];
    var title = jsxFactory_1.jsx("fragment", null,
        "Set text ",
        text,
        " to ",
        translateTarget(testLine.target),
        titleFragment);
    return jsxFactory_1.jsx("test-line", { title: title }, condition);
};
var assertUnknownBrowserCommand = function (browserCommand) {
    throw new Error("Unknown browser command: " + JSON.stringify(browserCommand));
};
var translateBrowserCommandTestLine = function (testLine, appConfig, elements) {
    var condition = testLine.condition ? conditions_1.translateCondition(testLine.condition, appConfig, elements) : undefined;
    switch (testLine.browserCommand.type) {
        case 'goBack':
            return jsxFactory_1.jsx("test-line", { title: "Go back" }, condition);
        case 'goForward':
            return jsxFactory_1.jsx("test-line", { title: "Go forward" }, condition);
        case 'refresh':
            return jsxFactory_1.jsx("test-line", { title: "Refresh" }, condition);
        case 'setWindowSize':
            return jsxFactory_1.jsx("test-line", { title: "Resize window" },
                jsxFactory_1.jsx("dictionary", null,
                    jsxFactory_1.jsx("row", null,
                        jsxFactory_1.jsx("cell", null, "Size"),
                        jsxFactory_1.jsx("cell", null,
                            jsxFactory_1.jsx("text", null,
                                String(testLine.browserCommand.params.width),
                                "x",
                                String(testLine.browserCommand.params.height))))),
                condition);
        case 'dismissAlertMessage':
            return jsxFactory_1.jsx("test-line", { title: "Dismiss modal dialog" }, condition);
        case 'acceptAlertMessage':
            return jsxFactory_1.jsx("test-line", { title: "Accept modal dialog" }, condition);
        case 'acceptPromptMessage':
            // TODO variables
            return jsxFactory_1.jsx("test-line", { title: "Accept modal dialog with message" },
                jsxFactory_1.jsx("dictionary", null,
                    jsxFactory_1.jsx("row", null,
                        jsxFactory_1.jsx("cell", null, "Message"),
                        jsxFactory_1.jsx("cell", null, testLine.browserCommand.params.text))),
                condition);
        default:
            return assertUnknownBrowserCommand(testLine.browserCommand);
    }
};
var translateClickTestLine = function (testLine, appConfig, elements) {
    var _a = __read(getConditionInfo(testLine, appConfig, elements), 2), titleFragment = _a[0], condition = _a[1];
    var title = jsxFactory_1.jsx("fragment", null,
        "Click on ",
        translateTarget(testLine.target),
        titleFragment);
    return jsxFactory_1.jsx("test-line", { title: title }, condition);
};
var translateMoveToTestLine = function (testLine, appConfig, elements) {
    var _a = __read(getConditionInfo(testLine, appConfig, elements), 2), titleFragment = _a[0], condition = _a[1];
    var title = jsxFactory_1.jsx("fragment", null,
        "Move pointer to ",
        translateTarget(testLine.target),
        titleFragment);
    return jsxFactory_1.jsx("test-line", { title: title }, condition);
};
var translateCommentTestLine = function (testLine) {
    return jsxFactory_1.jsx("test-line", { title: testLine.val });
};
var assertUnknownLineType = function (testLine) {
    throw new Error("Unknown line type: " + JSON.stringify(testLine));
};
exports.testLineToAst = function (testLine, appConfig, elements, snippets) {
    switch (testLine.type) {
        case 'assert':
        case 'wait':
            return translateAssertTestLine(testLine, appConfig, elements);
        case 'clearAppData':
            return translateClearAppDataTestLine();
        case 'execCmd':
            return translateExecuteCommandTestLine(testLine, appConfig);
        case 'openApp':
            return translateOpenApp(testLine, appConfig);
        case 'openUrl':
            return translateOpenUrl(testLine, appConfig);
        case 'sleep':
            return translateSleepTestLine(testLine, appConfig);
        case 'pollUrl':
            return translatePollUrlTestLine(testLine, appConfig);
        case 'button':
            return translatePressButtonTestLine(testLine, appConfig, elements);
        case 'runSnippet':
            return translateRunTestTestLine(testLine, appConfig, elements, snippets);
        case 'sendText':
            return translateSendTextTestLine(testLine, appConfig, elements);
        case 'setText':
            return translateSetTextTestLine(testLine, appConfig, elements);
        case 'browserCommand':
            return translateBrowserCommandTestLine(testLine, appConfig, elements);
        case 'click':
            return translateClickTestLine(testLine, appConfig, elements);
        case 'moveTo':
            return translateMoveToTestLine(testLine, appConfig, elements);
        case 'comment':
            return translateCommentTestLine(testLine);
        default:
            return assertUnknownLineType(testLine);
    }
};
//# sourceMappingURL=testLineToAst.js.map