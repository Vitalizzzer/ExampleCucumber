"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="../types/intrinsicElements.d.ts" />
/// <reference path="../types/unistTestLine.d.ts" />
var jsxFactory_1 = require("./jsxFactory");
var utils_1 = require("./utils");
var comparators_1 = require("./comparators");
var translateApplicationExitedCondition = function () {
    return jsxFactory_1.jsx("condition", { title: "Application has exited" });
};
var translateCurrentLocationCondition = function (condition, appConfig) {
    return jsxFactory_1.jsx("condition", { title: "Current location" },
        jsxFactory_1.jsx("table", null,
            jsxFactory_1.jsx("row", null,
                jsxFactory_1.jsx("cell", null, "Current location"),
                jsxFactory_1.jsx("cell", null, comparators_1.translateComparator(condition.type)),
                jsxFactory_1.jsx("cell", null, utils_1.formatVariables(condition.val, appConfig.configVariables)))));
};
var translateCookieCondition = function (condition, appConfig) {
    return jsxFactory_1.jsx("condition", { title: "Cookie" },
        jsxFactory_1.jsx("table", null,
            jsxFactory_1.jsx("row", null,
                jsxFactory_1.jsx("cell", null,
                    utils_1.formatVariables(condition.subject.val, appConfig.configVariables),
                    " cookie"),
                jsxFactory_1.jsx("cell", null, comparators_1.translateComparator(condition.type)),
                jsxFactory_1.jsx("cell", null, utils_1.formatVariables(condition.val, appConfig.configVariables)))));
};
// TODO - cover with unit tests
var translateElementProperty = function (property) {
    switch (property) {
        // Special cases, when converting from cameCase is not enough
        case 'videoUrl':
            return 'video URL';
        case 'url':
            return 'URL';
        case 'color':
            return 'text color';
        case 'zIndex':
            return 'z-index';
        case 'automationId':
            return 'automation ID';
        case 'scaleX':
            return 'scale X';
        case 'scaleY':
            return 'scale Y';
        case 'translationX':
            return 'translation X';
        case 'translationY':
            return 'translation Y';
        case 'pivotX':
            return 'pivot X';
        case 'pivotY':
            return 'pivot Y';
        case 'tagInt':
            return 'tag';
        case 'fontURI':
            return 'font URI';
        case 'proposalURL':
            return 'proposal URL';
        default:
            // Split camel case to words
            return property.replace(/([A-Z+])/g, function (_, match) { return ' ' + match.toLowerCase(); });
    }
};
var assertUnknownElementCondition = function (condition) {
    throw new Error("Unknown element condition type: " + JSON.stringify(condition));
};
var translateElementName = function (subject, elements) {
    var _a;
    if (subject.type === 'video' || ((_a = subject.val) === null || _a === void 0 ? void 0 : _a.video)) {
        return jsxFactory_1.jsx("bold", null, "video");
    }
    if ('elementId' in subject) {
        // Element defined by it's ID
        if (elements && elements[subject.elementId]) {
            return jsxFactory_1.jsx("bold", null, elements[subject.elementId].name);
        }
        if (subject.name) {
            // Deprecated TODO remove after BE feeds updated
            return jsxFactory_1.jsx("bold", null, subject.name);
        }
        if (subject.nameHint) {
            // In case element was removed and we no longer have it on record
            return jsxFactory_1.jsx("bold", null, subject.nameHint);
        }
        return jsxFactory_1.jsx("fragment", null,
            "Unknown element (",
            jsxFactory_1.jsx("code", null, subject.elementId.slice(0, 4) + '...' + subject.elementId.slice(-4)),
            ")");
    }
    if ('apiId' in subject) {
        // Element defined by it's API ID
        return jsxFactory_1.jsx("bold", null, subject.apiId);
    }
    // Otherwise it's a custom element defined by it's selector
    var _b = subject.val, ifMultipleFoundReturn = _b.ifMultipleFoundReturn, selector = __rest(_b, ["ifMultipleFoundReturn"]);
    var selectorKeys = Object.keys(selector);
    if (selectorKeys.length === 1) {
        // A common case when there is a single selector, e.g. css or xpath
        // Casting to any because TS throws an unwarranted error otherwise
        return jsxFactory_1.jsx("code", null, selector[selectorKeys[0]]);
    }
    return jsxFactory_1.jsx("code", null, JSON.stringify(__assign(__assign({}, selector), { index: (ifMultipleFoundReturn !== null && ifMultipleFoundReturn !== void 0 ? ifMultipleFoundReturn : 1) })));
};
var translateElementCondition = function (condition, appConfig, elements) {
    var elementName = translateElementName(condition.subject, elements);
    switch (condition.type) {
        case 'exists':
            return jsxFactory_1.jsx("condition", { title: jsxFactory_1.jsx("fragment", null,
                    elementName,
                    " exists") });
        case '!exists':
            return jsxFactory_1.jsx("condition", { title: jsxFactory_1.jsx("fragment", null,
                    elementName,
                    " does not exist") });
        case 'matches':
            var codeReplacedVars = utils_1.replaceVariables(condition.val, appConfig.configVariables);
            return jsxFactory_1.jsx("condition", { title: jsxFactory_1.jsx("fragment", null,
                    elementName,
                    " matches JavaScript") },
                jsxFactory_1.jsx("code-block", { label: "JavaScript matcher" }, codeReplacedVars),
                codeReplacedVars !== condition.val
                    ? jsxFactory_1.jsx("code-block", { label: "With variables" }, condition.val)
                    : undefined);
        case 'visible':
            return jsxFactory_1.jsx("condition", { title: jsxFactory_1.jsx("fragment", null,
                    elementName,
                    " is visible") });
        case 'has':
            return jsxFactory_1.jsx("condition", { title: jsxFactory_1.jsx("fragment", null,
                    elementName,
                    " properties") },
                jsxFactory_1.jsx("table", null, condition.expression.map(function (exp) { return (jsxFactory_1.jsx("row", null,
                    jsxFactory_1.jsx("cell", null, translateElementProperty(exp.property)),
                    jsxFactory_1.jsx("cell", null, comparators_1.translateComparator(exp.type)),
                    jsxFactory_1.jsx("cell", null, utils_1.formatVariables(exp.val + (exp.type === '+-' ? ' Â± ' + exp.deviation : ''), appConfig.configVariables)))); })));
        default:
            return assertUnknownElementCondition(condition);
    }
};
var translateJavaScriptExpressionCondition = function (condition, appConfig) {
    var code = utils_1.replaceVariables(condition.subject.val, appConfig.configVariables);
    return jsxFactory_1.jsx("condition", { title: "JavaScript expression" },
        jsxFactory_1.jsx("code-block", { label: "JavaScript expression" }, code),
        code !== condition.subject.val
            ? jsxFactory_1.jsx("code-block", { label: "With variables" }, condition.subject.val)
            : undefined,
        jsxFactory_1.jsx("table", null,
            jsxFactory_1.jsx("row", null,
                jsxFactory_1.jsx("cell", null, "Expression result"),
                jsxFactory_1.jsx("cell", null, comparators_1.translateComparator(condition.type)),
                jsxFactory_1.jsx("cell", null, utils_1.formatVariables(condition.val, appConfig.configVariables)))));
};
var translateNetworkInfo = function (isRequest, appConfig) { return function (_a) {
    var name = _a.name, compare = _a.compare, val = _a.val;
    return jsxFactory_1.jsx("row", null,
        jsxFactory_1.jsx("cell", null,
            jsxFactory_1.jsx("text", null,
                isRequest ? 'Request' : 'Response',
                " "),
            name.startsWith('@')
                ? jsxFactory_1.jsx("text", null, name.slice(1))
                : jsxFactory_1.jsx("fragment", null,
                    "header ",
                    utils_1.formatVariables(name, appConfig.configVariables))),
        jsxFactory_1.jsx("cell", null, comparators_1.translateComparator(compare)),
        jsxFactory_1.jsx("cell", null, utils_1.formatVariables(String(val), appConfig.configVariables)));
}; };
/**
 * Put @status and @method on top, then show headers, then - @body.
 * This order is more familiar to user and closer to HTTP raw request/response.
 *
 * Ordering might be off for headers if variables are used for header names, but that is minor
 */
var sortNetworkInfo = function (a, b) {
    // Method and status always on top
    if (['@method', '@status'].includes(a.name)) {
        return -1;
    }
    if (['@method', '@status'].includes(b.name)) {
        return 1;
    }
    // Body always last
    if (a.name === '@body') {
        return 1;
    }
    if (b.name === '@body') {
        return -1;
    }
    return a.name > b.name ? -1 : 1;
};
var translateNetworkRequestCondition = function (condition, appConfig) {
    var _a, _b, _c, _d;
    var requestInfo = (_b = (_a = condition
        .subject
        .requestInfo) === null || _a === void 0 ? void 0 : _a.sort(sortNetworkInfo).map(translateNetworkInfo(true, appConfig)), (_b !== null && _b !== void 0 ? _b : []));
    var responseInfo = (_d = (_c = condition
        .subject
        .responseInfo) === null || _c === void 0 ? void 0 : _c.sort(sortNetworkInfo).map(translateNetworkInfo(false, appConfig)), (_d !== null && _d !== void 0 ? _d : []));
    var tableRows = requestInfo.concat(responseInfo);
    return jsxFactory_1.jsx("condition", { title: jsxFactory_1.jsx("text", null,
            "Network request ",
            condition.type === 'made' ? 'was made' : 'was not made') },
        jsxFactory_1.jsx("dictionary", null,
            jsxFactory_1.jsx("row", null,
                jsxFactory_1.jsx("cell", null, condition.subject.compare === '=' ? 'Exact URL' : 'URL matching'),
                jsxFactory_1.jsx("cell", null, utils_1.formatVariables(condition.subject.val, appConfig.configVariables))),
            jsxFactory_1.jsx("row", null,
                jsxFactory_1.jsx("cell", null, "Previously matched"),
                jsxFactory_1.jsx("cell", null,
                    jsxFactory_1.jsx("bold", null, condition.searchStrategy === 'all' ? 'Yes' : 'No')))),
        tableRows.length
            ? jsxFactory_1.jsx("table", { label: "Network request properties" }, tableRows)
            : undefined);
};
var assertUnknownConditionSubject = function (subject) {
    throw new Error("Unknown condition subject: " + JSON.stringify(subject));
};
/**
 * Translate condition part of the test line into human readable strings
 * "elements" is optional property. BE is going to update results feed to include elements map,
 * but for now it can be omitted
 */
exports.translateCondition = function (condition, appConfig, elements) {
    switch (condition.subject.type) {
        case 'element':
        case 'video':
            return translateElementCondition(condition, appConfig, elements);
        case 'javascript':
            return translateJavaScriptExpressionCondition(condition, appConfig);
        case 'location':
            return translateCurrentLocationCondition(condition, appConfig);
        case 'cookie':
            return translateCookieCondition(condition, appConfig);
        case 'network':
            return translateNetworkRequestCondition(condition, appConfig);
        case 'application':
            return translateApplicationExitedCondition();
        default:
            return assertUnknownConditionSubject(condition.subject);
    }
};
//# sourceMappingURL=conditions.js.map