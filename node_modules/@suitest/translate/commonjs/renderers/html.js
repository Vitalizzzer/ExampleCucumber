"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="../../types/unistTestLine.d.ts" />
var jsxFactory_1 = require("../jsxFactory");
var utils_1 = require("../utils");
/**
 * Helper function to build HTML figure element
 * @param className - class name to be added to figure
 * @param content - body content of the figure, already renderer to string
 * @param titleNodes - optional figcaption
 * @param prefix - text to insert before figcaption
 */
var renderFigure = function (className, content, titleNodes, prefix) {
    if (prefix === void 0) { prefix = ''; }
    var _a;
    var output = ["<figure class=\"" + className + "\">"];
    if ((_a = titleNodes) === null || _a === void 0 ? void 0 : _a.length) {
        output.push("<figcaption>" + (prefix + titleNodes.map(renderNode).join('')) + "</figcaption>");
    }
    output.push(content, '</figure>');
    return output.join('');
};
var renderHtmlCodeBlockNode = function (node) { return renderFigure('suitest-test-line__code-block', "<pre><code>" + node.value + "</code></pre>", node.label); };
var renderHtmlDictionaryNode = function (node) { return renderFigure('suitest-test-line__dictionary', __spread([
    '<dl>'
], node.children.map(function (row) { return (__spread([
    '<dt>'
], row.children[0].children.map(renderNode), [
    '</dt><dd>'
], row.children[1].children.map(renderNode), [
    '</dd>',
])).join(''); }), [
    '</dl>',
]).join(''), node.label); };
var renderHtmlTableNode = function (node) { return renderFigure('suitest-test-line__table', __spread([
    '<table>'
], node.children.map(function (row) { return (__spread([
    '<tr>'
], row.children.map(function (cell) { return '<td>' + cell.children.map(renderNode).join('') + '</td>'; }), [
    '</tr>',
]).join('')); }), [
    '</table>',
]).join(''), node.label); };
var renderHtmlConditionNode = function (node) { return renderFigure('suitest-test-line__condition', node.children.map(renderNode).join(''), node.title, 'Condition: '); };
var renderHtmlTestLineNode = function (node) { return renderFigure('suitest-test-line', node.children.map(renderNode).join(''), node.title); };
var renderNode = function (node) {
    var _a, _b, _c;
    switch (node.type) {
        case 'text':
            return utils_1.escapeHtml((_a = node.value, (_a !== null && _a !== void 0 ? _a : '')));
        case 'code':
            return "<code class=\"suitest-test-line__text--code\">" + (_b = node.value, (_b !== null && _b !== void 0 ? _b : '')) + "</code>";
        case 'bold':
        case 'emphasis':
            return "<span class=\"suitest-test-line__text--" + node.type + "\">" + utils_1.escapeHtml((_c = node.value, (_c !== null && _c !== void 0 ? _c : ''))) + "</span>";
        case 'paragraph':
            return "<p class=\"suitest-test-line__paragraph\">" + node.children.map(renderNode).join('') + "</p>";
        case 'code-block':
            return renderHtmlCodeBlockNode(node);
        case 'dictionary':
            return renderHtmlDictionaryNode(node);
        case 'table':
            return renderHtmlTableNode(node);
        case 'test-line':
            return renderHtmlTestLineNode(node);
        case 'condition':
            return renderHtmlConditionNode(node);
        case 'row':
        case 'cell':
            throw new Error('Cell and Row nodes can only be rendered as part of table or dictionary');
        default:
            return jsxFactory_1.assertUnknownSectionNode(node);
    }
};
exports.toHtml = function (node) {
    if (!Array.isArray(node)) {
        node = [node];
    }
    return node.map(renderNode).join('');
};
//# sourceMappingURL=html.js.map