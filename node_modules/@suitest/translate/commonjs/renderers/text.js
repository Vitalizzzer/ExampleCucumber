"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="../../types/unistTestLine.d.ts" />
var jsxFactory_1 = require("../jsxFactory");
var nl = '\n';
var tab = '  ';
var format = {
    cancel: '\u001b[0m',
    green: '\u001b[32m',
    cyan: '\u001b[36m',
    underscore: '\u001b[4m',
};
/**
 * Render a single text node as plain text
 */
var renderPlainTextNode = function (node) { return node.value; };
/**
 * Render a single text node with TTI colors
 */
var renderFormattedTextNode = function (node) {
    var _a;
    var value = (_a = node.value, (_a !== null && _a !== void 0 ? _a : ''));
    switch (node.type) {
        case 'text':
            return value;
        case 'bold':
            return format.green + value + format.cancel;
        case 'emphasis':
            return format.underscore + value + format.cancel;
        case 'code':
            return format.cyan + value + format.cancel;
        default:
            return jsxFactory_1.assertUnknownTextNode(node);
    }
};
/**
 * Split a single AST node into several based on provided length of the first node
 */
var splitNode = function (textNode, length) { return ([
    __assign(__assign({}, textNode), { value: textNode.value.slice(0, length) }),
    __assign(__assign({}, textNode), { value: textNode.value.slice(length) }),
]); };
/**
 * Wrapped textual nodes to fit max length
 * @TODO consider wrapping by word and not by any character
 */
var wrappedTextNodes = function (textNodes, maxLineLength) {
    if (maxLineLength === void 0) { maxLineLength = 60; }
    // Keep function immutable
    textNodes = __spread(textNodes);
    var output = [[]];
    var maxActualLength = 0;
    var currentLineLength = 0;
    while (textNodes.length) {
        var firstNode = textNodes.shift();
        if (firstNode.value.length < maxLineLength - currentLineLength) {
            // The whole textNode can fit into the line
            currentLineLength += firstNode.value.length;
            output[output.length - 1].push(firstNode);
            maxActualLength = currentLineLength > maxActualLength ? currentLineLength : maxActualLength;
        }
        else {
            // Need to split text node
            var splitNodes = splitNode(firstNode, maxLineLength - currentLineLength);
            currentLineLength = 0;
            output[output.length - 1].push(splitNodes[0]);
            output.push([]);
            textNodes.splice(0, 1, splitNodes[1]);
            maxActualLength = maxLineLength;
        }
    }
    return [maxActualLength, output];
};
var renderDictionary = function (node, renderTextNode, prefix) {
    if (prefix === void 0) { prefix = ''; }
    var _a;
    var label = ((_a = node.label) === null || _a === void 0 ? void 0 : _a.length) ? nl + prefix + node.label.map(renderTextNode).join('') + nl : '';
    var renderedRowsWithMaxLength = node.children
        .map(function (row) { return row.children.map(function (cell) { return wrappedTextNodes(cell.children); }); });
    var maxTermLength = renderedRowsWithMaxLength
        .reduce(function (acc, _a) {
        var _b = __read(_a, 1), _c = __read(_b[0], 1), termLength = _c[0];
        return acc > termLength ? acc : termLength;
    }, 0);
    return label + renderedRowsWithMaxLength.map(function (_a) {
        var _b = __read(_a, 2), _c = __read(_b[0], 2), term = _c[1], _d = __read(_b[1], 2), definition = _d[1];
        var _e, _f;
        var lines = [];
        while (term.length || definition.length) {
            lines.push([
                prefix,
                (_e = term.shift(), (_e !== null && _e !== void 0 ? _e : [])).map(renderTextNode).join('').padStart(maxTermLength),
                (lines.length ? '  ' : ': '),
                (_f = definition.shift(), (_f !== null && _f !== void 0 ? _f : [])).map(renderTextNode).join(''),
            ].join(''));
        }
        return lines.join(nl);
    }).join(nl) + nl;
};
var renderTable = function (node, renderTextNode, prefix) {
    if (prefix === void 0) { prefix = ''; }
    var _a;
    var label = ((_a = node.label) === null || _a === void 0 ? void 0 : _a.length) ? nl + prefix + node.label.map(renderTextNode).join('') + nl : '';
    var renderedRowsWithMaxLength = node.children
        .map(function (row) { return row.children.map(function (cell) { return wrappedTextNodes(cell.children); }); });
    var columnWidth = renderedRowsWithMaxLength.reduce(function (acc, row) {
        row.forEach(function (_a, i) {
            var _b = __read(_a, 1), cellLength = _b[0];
            var _c;
            if (cellLength > (_c = acc[i], (_c !== null && _c !== void 0 ? _c : 0))) {
                acc[i] = cellLength;
            }
        });
        return acc;
    }, []);
    var rows = [];
    renderedRowsWithMaxLength.map(function (row) {
        var rowLines = [];
        while (row.some(function (cell) { return cell[1].length; })) {
            rowLines.push([
                prefix,
                '│ ',
                row.map(function (_a, i) {
                    var _b = __read(_a, 2), cell = _b[1];
                    var _c;
                    return (_c = cell.shift(), (_c !== null && _c !== void 0 ? _c : [])).map(renderTextNode).join('').padEnd(columnWidth[i]);
                }).join(' │ '),
                ' │',
            ].join(''));
        }
        rows.push(rowLines.join(nl));
    });
    return label + prefix + '┌' + columnWidth.map(function (column) { return ''.padStart(column + 2, '─'); }).join('┬') + '┐' + nl +
        rows.join('\n' + prefix + '├' + columnWidth.map(function (column) { return ''.padStart(column + 2, '─'); }).join('┼') + '┤' + '\n') +
        nl + prefix + '└' + columnWidth.map(function (column) { return ''.padStart(column + 2, '─'); }).join('┴') + '┘';
};
var renderCodeBlock = function (node, renderTextNode, prefix) {
    if (prefix === void 0) { prefix = ''; }
    var _a;
    var codeBlockPrefix = prefix;
    var label = '';
    if ((_a = node.label) === null || _a === void 0 ? void 0 : _a.length) {
        label = nl + prefix + node.label.map(renderTextNode).join('');
        codeBlockPrefix += tab;
    }
    return label + nl + node.value.split(nl).map(function (line) { return codeBlockPrefix + '> ' + line; }).join(nl) + nl;
};
var renderNode = function (node, renderTextNode, prefix) {
    if (prefix === void 0) { prefix = ''; }
    switch (node.type) {
        case 'text':
        case 'code':
        case 'emphasis':
        case 'bold':
            return renderTextNode(node);
        case 'paragraph':
            return prefix + node.children.map(renderTextNode).join('') + nl;
        case 'code-block':
            return renderCodeBlock(node, renderTextNode, prefix);
        case 'dictionary':
            return renderDictionary(node, renderTextNode, prefix);
        case 'table':
            return renderTable(node, renderTextNode, prefix);
        case 'test-line':
            return renderTestLineOrCondition(node, renderTextNode);
        case 'condition':
            return nl + prefix + 'Condition: ' + renderTestLineOrCondition(node, renderTextNode, prefix + tab);
        case 'cell':
        case 'row':
            throw new Error('Cell and Row nodes can only be rendered as part of table or dictionary');
        default:
            return jsxFactory_1.assertUnknownSectionNode(node);
    }
};
var renderTestLineOrCondition = function (node, renderTextNode, prefix) {
    if (prefix === void 0) { prefix = ''; }
    var title = node.title.map(renderTextNode).join('');
    var body = node.children.map(function (child) { return renderNode(child, renderTextNode, prefix + tab); }).join('');
    return title + nl + body;
};
exports.toText = function (node, format) {
    if (format === void 0) { format = true; }
    var renderTextNode = format ? renderFormattedTextNode : renderPlainTextNode;
    if (!Array.isArray(node)) {
        node = [node];
    }
    return node.map(function (n) { return renderNode(n, renderTextNode); }).join('');
};
//# sourceMappingURL=text.js.map